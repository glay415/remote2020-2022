## 객체 지향(Object-Oriented)

- [객체지향을 향해](#객체지향을-향해)
- [객체지향 개발단계](#객체지향-개발단계)
- [객체지향 프로그래밍 개념](#객체지향-프로그래밍-개념)
- [객체지향 설계원칙](#객체지향-설계원칙)
- [객체지향 프로그래밍의 장점](#객체지향-프로그래밍의-장점)

----

### 개요

- 객체지향을 자세하게 공부해보자!

---

## 객체지향을 향해

- 진정한 객체지향 패러다임으로의 전환은 Class가 아닌, Object에 초점을 맞출 때에 이룰 수 있다.

> 어떤 클래스가 필요한지가 아니라 어떤객체가 필요한지 고민해야 한다.
>
> 객체는 독립적인 존재가 아니다, 기능 구현을 위해 협력하는 공동체의 일원으로 보아야한다

## 객체지향 개발단계

### OOA(Object-Oriented Anaysis)

- 요구사항을 정의하고 이 정의로부터 model들을 제작하여 실세계의 중요한 특성들을 보여주는 단계
- 다음과 같은 모형 들이 만들어 질 수 있다.
  - 객체 모형(Object Model) : 객체들과 그 특성을 식별하여 객체들의 정적 구조와 그들간의 관계를 모여주는 객체 다이어그램을 작성한다.
  - 동적 모형(Dynamic Model) : 시간 흐름에 따른 시스템의 변화를 보여주는 상태 다이어그램을 작성한다. 식ㄹ시간 시스템에서는 반드시 필요하다.
  - 기능 모형(Fuction Model) : 시스템 내에서 데이타 값이 변하는 과정을 보여주는 것으로 잘 알려진 자료 흐름도(DFD)가 사용된다.
- Use-case Modeling, Class Modeling, Dynamic Modeling의 세 단계가 있다. (생략)

### OOD(Object-Oriented Design)

- 객체지향 설계는 시스템 설계와 객체 설계로 크게 나뉘어 진다.
  - 시스템 설계(System Design) : 시스템의 구조를 서브시스템으로 분해한다. 이 과정중에서 성능 최적 방안, 문제 해결 전략, 자원 분배 등이 확정된다.
  - 객체 설계(Object Design) : 구현에 필요한 상세한 내역을 설계 모형으로 제작하고 상세화된다. 구체적인 자료구조와 알고리즘 들이 정의된다.

### OOP(Object-Oriented Programming)

- 설계 모형을 특정 프로그래밍 언어로 번역하는 작업이다.
- 객체지향 언어가 가장 좋지만 객체기반 언어도 좋다.
- 구조적 프로그래밍 언어도 객체지향 개발에 활용될 수 있는가 하면 OODBMS가 개발의 도구로 이용될 수 있다.

## 객체지향 프로그래밍 개념

대형 소프트웨어를 제작할 때 프로그램들간의 중복성과 개발이후 유지 보수의 어려움의 문제를 해결하기 위해 등장한 프로그래밍 패러다임이다.

데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고, 그 객체들 간 유기적인 상호작용을 통해 로직을 구성한다.

OOP는 추상 자료형(abstract data type), 객체(object), 클래스(class), 상속(inheritance), 정보 은닉(information hiding/encapsulation), 다형성(polymorphism), 재사용성(reusability) 등의 중요한 개념들을 바탕으로 탄생했다.

### 추상화

**공통의 속성이나 기능을 묶어 이름을 붙이는 것**

- OOP적 관점에서 클래스를 정의하는 것을 바로 추상화라고 정의 내릴 수 있다.
- 데이터 추상화는 부주의한 버그의 수정을 경감하는데 도움이 된다. 이는 객체의 데이타와 메소드로 만들어진 변경을 국지화(localization) 하기 때문이다.
  - 이러한 객체마다에 대한 국지화는 점진적 개발과 시제품화(prototype) 시의 버그의 개입을 막아준다.

### 캡슐화

**데이터 구조나 데이터를 다루는 방법들을 결합 시켜 묶는 것**

- 객체가 맡은 역할을 수행하기 위한 하나의 목적을 한데 묶는다.
- 어떠한 객체도 다른 객체의 상태를 직접 읽거나 변경시킬 수 없다.
  - 객체의 상태를 접근하는 것은 인터페이스 메소드를 통해서 달성된다.
  - 이때의 접근은 객체 자신이 그것을 허용할 때에만 가능하다.
    - 이러한 데이터 은닉화 또는 데이터 추상화는 객체간의 결합성을 약화시키는 효과를 가진다.
- 데이터를 보이지 않고 외부와 상호작용을 할 떄는 메소드를 이용하여 통신을 한다. 보통 라이브러리로 만들어서 업그레이드해 사용할 수 있다.
- 명확히 정의된 인터페이스와 메세지 전달의 사용을 통해 객체의 데이타 및 메소드 구현을 캡슐화 하는 것은 객체간의 숨겨진 종속성이 형성되는 것을 방지한다.

### 추상 자료형

**사용자 정의의 데이터 타입을 추상 자료형이라고 한다, OOP에서는 이 추상 자료형의 개념이 객체로 전달된다.**

- 추상 자료형은 인터페이스와 구현을 분리하여 추상화 계층을 둔 것으로 추상 자료형에 대한 구현은 외부로 부터 숨겨져 정보 은닉이 이루어지게 된다.
- 사용자에게 물리적 정보의 저장소를 숨기지만, 사용자가 객체의 속성들을 조작하기 위해 호출할 수 있는 메소드의 공용 집합을 제공한다.

### 객체 

**객체는 데이터(속성 또는 성질)와 기능적 논리(메소드)들의 집단이다.**

- 메소드(method)는 객체의 행위를 정의한다.
  - 메소드는 두 가지 종류가 이는데, 그 하나는 객체간의 통신 수단이 되는 인터페이스 메소드이며, 또 다른 하나는 객체행위를 만들어 내지만 객체 외부에서는 접근할 수 없는 내부 메소드이다.
- OOP에서는 method들만이 그 객체의 데이터들을 access할 수 있다.
- 다른 객체들에게 이러한 method들을 통해서 어떤 작업을 요청 할 수 있는데, 이것을 message passing이라고 한다.
  - 이러한 사상으로 객체들간의 함부로 다른 객체들의 데이터를 변경시킬 수 없도록하여 정보를 은닉한다.
  - 또한 일정 경로(method) 만을 통하여 변경 가능하게 함으로써 객체의 데이터 보전성(integrity) 을 높일 수 있고, 소프트웨어 유지 보수시에 비용을 절감할 수 있다.
- 어느 한 시점에서 어떤 객체가 가지고 있는 데이터들은 그 객체의 상태(state) 를 나타낸다고 볼 수 있다.
  - 그러므로 객체지향 시스템 전체의 상태는 그것이 가지고 있는 객체들의 상태로 설명된다고 볼 수 있다.
- 각 객체는 주체성(identity)에 의해 유일하게 식별되는데, 이 객체 주체성은 재래식 프로그래밍 언어의 포인터, 운영체제에서의 화일 명의 개념을 확장한 것이다.
  - 객체의 주체성은 객체의 상태와는 별개로서, 두개의 객체가 같은 상태를 가질 수 있으나 주체성은 서로 다르다.
- 객체지향 시스템은 객체가 속성을 가지도록 하는데 그 속성자체가 객체자신이다.
  - 이것은 추상 자료형을 통해 달성된다.

#### message passing

**객체는 메세지를 전달함으로써 다른 객체들과 통신을 한다.**

- 메세지는 목적지를 식별하는 이름을 가지고 있을 뿐만 아니라 인수나 매개변수를 갖기도 한다.
  - 이것은 전통적인 함수 호출 또는 프로시저 호출과 유사하다.
  - 그렇지만 메세지는 전통적인 함수 호출에 관련된 것보다 더 복잡한 송신자로부터 수신자까지의 경로를 포함할 수 있다.

### 클래스

**클래스란 객체들을 생성하는 형판(temp-late) / 다수의 유사한 객체들을 일반화된 서술로 같이 묶어 기술한 것**

- 클래스의 개념은 데이터 타입의 개념과 비슷하다.(클래스는 하나의 타입이다. 그러나 모든 타입이 클래스는 아니다.)
- 같은 타입을 갖는 객체들은 그 타입을 정의한 하나의 클래스에서 생성될 수 있다.
- 클래스의 method들은 묵맹상에 위치하여 클래스에 의해 생성된 객체들이 이 method들을 공유하여 사용한다.
  - 따라서 여러 개의 클래스들이 계층 구조를 이룰 때 클래스의 지역 변수들은 구조를 형성하는데 이용되며 method들은 행위(behavior) 를 나타내는 데 이용된다.
- 어떤 클래스로부터 생성(instantiation) 된 객체를 그 클래스의 instance라 한다.
- 객체지향 시스템은 클래스들의 집합으로볼 수 있다.
  - 각각의 클래스들은 시스템이 목적하는바를 달서하기 위한 데이터와 그에관한 인터페이스 함수들을 기술한 추상자료형을 구현한 것으로 볼 수 있다.
  - 하나의 클래스는 하나의 타입을 기술한 것이고, 그 객체는 그 타입의 instance이다.
- 클래스의 개념은 정적이고 객체는 동적인 개념이다.
  - 클래스는 프로그램상에 정적으로 존재하고, 객체는 실행시 실제 메모리상에 동적으로 생성, 소멸된다.

### 상속

**상속은 객체지향 프로그래밍이 다른 프로그래밍 패러다임과 차별되는 주요 개념으로 어떠한 클래스가 다른 클래스의 속성(데이터 및 methods) 을 물려받는 것이다**

- 상속은 소프트웨어의 원소인 객체혹은 클래스들의 재사용을 목적으로 한다.
- 상속ㄷ은 클래스들 간의 데이터와 메소드의 공유를 허용하는 OOPL의 주요 메커니즘 이다.
- 하위 클래스는 상위 클래스의 속성인 지역 변수들과 method들을 물려 받고 새로운 지역 변수 및 method들을 정의한다.
  - 이때 상위 클래스의 지역 변수나 method들의 이름을 다른 이름으로 정의할 수 있고, 같은 이름의 method들이지만 그 내용을 바꿀 수 있다.
  - 또한 하위 클래스는 상위 클래스의 속성을 전부 물려받을 수 있고, 혹은 선택적으로 물려받을 수 있다.
- 새로 정의하고자 하는 한 클래스가 기존의 어떤 클래스의 많은 부분 혹은 대부분의 속성과 같을 때 그 클래스의 하위 클래스로 정의하여 기존 클래스 속성을 상속받을 수 있도록 하고, 고유의 속성은 따로 정의하여 새로운 클래스를 만든다(specialization)
- 어떤 클래스가 다른 클래스와 부분적으로 같은 속성을 가지고 있을 경우, 어떤 새로운 한 클래스를 생성하여 상위 클래스로 놓고, 앞의 두 클래스를 이 새로운 상위 클래스의 하위 클래스들로 구성하여, 두 하위 클래스의 공통 속성을 이 상위 클래스에 정의하여 두 하위 클래스가 그것을 상속받아 사용할 수 있도록 한다(generalization)
  - 이경우 하위 클래스들에 중복하여 정의될 공통 부분이 상위 클래스에 한번만 정의되면, 하위 클래스들에서 재사용이 가능하므로 비용 절감이 가능하다.
- 어떤 하위 클래스가 두개 이상의 상위 클래스로 부터 상속을 받는 경우를 다중 상속이라고 한다.
  - 일반적으로 실세계를 객체지향으로 모델링할 때 단일 상속보다는 다중 상속일 경우가 많다.
  - 다중 상속은 단일 상속보다 개념적으로 어렵고 구현하기도 어렵다.

- 단일 상속, 다중 상속, 반복 상속, 선택적 상속등의 형태가 존재한다.

### 다형성

**다형성은 실제 메세지가 어떤 데이터 타입으로 어떻게 구현되었는지 몰라도 원하는 결과를 위해 일반적으로 정의된 메세지를 사용할 수 있도록 해주는 기법**

- OOP에서는 다형성을 사용하여 같은 메세지를 상위 및 하위 클래스에 보낼 수 있다.
- 자바에서는 다형성을 위해 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하고 있다.
  - 이때 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 같거나 적어야 참조할 수 있다.
  - 특정 타입의 참조 변수로 같은 타입의 인스턴스를 참조할 수 있다.
  - 또한 부모 클래스 타입의 참조 변수로도 작식 클래스 타입의 인스턴스를 참조할 수 있다.
- 자바에서는 참조 변수도 다음과 같은 조건에 따라 타입 변환을 할 수 있다.
  - 서로 상속 관계에 있는 클래스 사이에만 타입 변환을 할 수 있다.
  - 자식 클래스 타입에서 부모 클래스 타입으로의 타입 변환을 생략할 수 있다.
  - 부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시해야 한다.
- 이러한 다형성으로 인해 런타임에 참조 변수가 실제로 참조하고 있는 인스턴스의 타입을 확일할 필요성이 생긴다.
  - 자바에서는 instanceof연산자를 제공하며, 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 확인할 수 있도록 해준다.
- 포함 다형성, 연산 다형성, 매개 변수 다형성 이렇게 3가지의 형태가 있다.

### 동적 바인딩

**동적 바인딩은 실행시 융통성을 부여하고, 보다 높은 문제 추상화를 제공한다**

- 프로그램에서 변수, 객체와 코드의 실제 주소 및 값 등을 알 수 있게 하는 것을 바인딩이라고 하고, 바인딩이 일어나는 시간을 바인딩 시간, 바인딩이 컴파일 시간에 일어나는 것을 정적 바인딩, 실행 시간에 일어나면 동적 바인딩이라 한다.
- 정적 바인딩은 실행전 코드 최적화등을 통하여 실행 시간의 효율을 높일 수 있다.
  - 하지만 컴파일 시간의 정적 바인딩만으로 해결되지 않는 부분은 동적 바인딩을 통해야 한다.
- 메세지를 보낼 때 객체 자신에게 직접 보내는 기법보다는 그 객체를 가리키는  포인터에 보내는 기법을 사용하면, 그 객체 포인터는 실행 시간에 결정되므로, 실행시에 보다 적절한 코드를 찾아 수행 할 수 있도록 해준다.
- C++에서는 GC등의 기능을 갖지 않으므로, 프로그램에서 객체들을 위한 메모리 할당 및 회수를 책임진다.

## 객체지향 설계원칙

### SOLID

**로버트 C. 마틴이 2000년대 초반에 명명한 OOD의 다섯 가지 기본 원칙이다**

- SOLID 원칙은 강력하고 확장 가능하며 유지 관리 가능한 객체지향 응용 프로그램을 구축하기 위한 기본 지침을 형성한다.

- 시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 적용할 수 있다.

**SOLID 원칙은 좋은 원칙이고 좋은 조언이지만 순수한 진실도 아니고 규칙도 아니다**

### 단일 책임 원칙(Single Responsibility Principle)

**하나의 클래스는 하나의 책임만 가져야 함**

- 단일 책임 원칙은 특정 객체의 책임, 의존성 과중을 최대한 지양하기 위한 원칙이다.
- 혼재된 책임들을 각각의 개별 클래스로 분할하여 클래스 당 하나의 책임만을 맡도록 하는 것이다.

```java
public class Vehicle {
    public void printDetails() {}
    public double calculateValue() {}
    public void addVehicleToDB() {}
}
```

- 이 Vehicle클래스에는 인쇄, 계산및 DB의 세 가지 별도 책임이 있다.
- SRP를 적용하여 Vehicle클래스를 별도의 책임을 가진 세 개의 클래스로 나눌 수 있다.

### 개방 폐쇄 원칙(Open Closed Principle)

**소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 함**

- 변경되어야 하는 부분을 추상화로 분리하여 다른 clss들은 영향이 받지 않도록 하고, 계속 변경되는 부분은 이를 기반으로 새롭게 구현하도록 하여 확장이 가능하게 하는 원칙이다.
- 요구사향의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나면 안된다.
- 주로 인터페이스나 상속을 통해 핵심 부분을 추상화 시켜 유연성을 더한다.
- 코드의 수정을 최소화하여 결합도는 줄이고 응집도를 높이는 효과를 볼 수 있다.

![database](https://camo.githubusercontent.com/640ca37845199c7a794e3fea5b06c44da4278243205a4a466cffd4ee8e96c0ba/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f72793226666e616d653d687474702533412532462532466366696c65312e75662e746973746f72792e636f6d253246696d61676525324632333731344434303536393834433344334136364643)

- 개방 폐쇄 원칙의 예로 JDBC를 꼽을 수 있다.

```java
void checkOut(Receipt receipt) {
  Money total = Money.zero;
  for (item : items) {
    total += item.getPrice();
    receipt.addItem(item);
  }
  Payment p = acceptCash(total);
  receipt.addPayment(p);
}
```

- 위 코드에서 신용 카드 지원을 추가하기 위해선 아래와 같이 if문을 추가할 수 있다.

```java
Payment p;
if (credit)
  p = acceptCredit(total);
else
  p = acceptCash(total);
receipt.addPayment(p);
```

- 하지만 이는 OCP를 위반하는 것이다.

````java
public interface PaymentMethod {void acceptPayment(Money total);}

void checkOut(Receipt receipt, PaymentMethod pm) {
  Money total = Money.zero;
  for (item : items) {
    total += item.getPrice();
    receipt.addItem(item);
  }
  Payment p = pm.acceptPayment(total);
  receipt.addPayment(p);
}
````

- 더 나은 솔루션은 위와 같다.
- OCP는 다가올 변경 사항이 예측 가능한 경우에만 도움이 되므로 유사한 변경 사항이 이미 발생한 경우에만 적용해야 한다.
  - 따라서 먼저 가장 간단한 작업을 수행한 다음 요청된 변경 사항을 확인하여 향후 변경 사항을 보다 정확하게 예측할 수 있다.

### 리스코프 치환 원칙(Listov Substitution Principle)

**파생 클래스는 기본 클래스를 대체할 수 있어야 함**

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 서브 클래스가 확장에 대한 인터페이스를 준수해야 함을 말한다.
- 

```c++
void f(Ptype x) {
  //...
 }
 
 Class Ctype extends Ptype {
  //...
 }
```

- 위의 코드와 같이 구현되어 있는 경우는 이 원칙을 잘 따른다고 볼 수 있다. 
- 하지만, 만약에 함수 f()가 Ctype을 받았을 경우 오동작하게 되면 원칙을 위배하게 되는 것이다. 
- 또한, f()가 Ctype의 내용을 가지고 내용을 접근한다고 하면 OCP도 위배하게 된다.

### 인터페이스 분리 원칙(Interface Segregation Principle)

**클라이언트별로 세분화된 인터페이스를 만들어야 함**

- 인터페이스를 클라이언트에 특화되도록 분리시키라는 것으로 범용의 공통적인 인터페이스를 여러 클래스가 공유해서 사용하지 말라는 것이다.
- 응집력이 없는 인터페이스가 있을때 ISP는 더 작고 응집력 있는 여러 인터페이스를 만들도록 안내한다.
- ISP를 적용하면 클래스와 해당 종속성이 밀접하게 중심된 인터페이스를 사용하여 통신하여 사용되지 않는 구성원에 대한 종속성을 최소화하고 그에 따라 결합을 줄인다.
  - 인터페이스가 작을수록 구현하기 쉽고 유연성과 재사용 가능성이 향상된다.

```java
public interface Vehicle {
    public void drive();
    public void stop();
    public void refuel();
    public void openDoors();
}
public class Bike implements Vehicle {

    // Can be implemented
    public void drive() {...}
    public void stop() {...}
    public void refuel() {...}
    
    // Can not be implemented
    public void openDoors() {...}
}
```

- Bike 차량 및 클레스에 대한 인터페이스가 있다고 가정합니다.
- Bike에는 문이 없기 때문에 Bike클래스에 openDoors메서드를 구현하는 것은 의미가 없다.
- 이 문제를 해결하기 위해 ISP는 인터페이스를 여러 개의 작은 응집력 있는 인터페이스로 분할하여 클래스에 필요하지 않는 인터페이스와 메서드를 강제로 구현하지 않도록 할 것을 제안한다.

### 의존관계 역전 원칙(Dependency Inversion Principle)

**구체화에 의존하지 말고 추상화에 의존해야 함**

- 의존 관계를 맺을 때 변하기 쉬운것 또는 자주 변하는 것 보다는 변화하기 어려운 것 또는 거의 변화가 없는 것에 의존해야 함

```java
public class Car {
    private Engine engine;
    public Car(Engine e) {
        engine = e;
    }
    public void start() {
        engine.start();
    }
}
public class Engine {
   public void start() {...}
}
```

- 위 코드의 Car클래스는 Engine이라는 구체적인 클래스에 의존하므로 DIP를 따르지 않는다.
- 위 코드에서 다른 엔진 유형을 추가하려면 Car클래스를 리팩토링 해야한다.

```java
public interface Engine {
    public void start();
}
```

- 추상화 계층을 도입하여 직접의존하는 대신 Engine인터페이스를 추가하였다.

```java
public class Car {
    private Engine engine;
    public Car(Engine e) {
        engine = e;
    }
    public void start() {
        engine.start();
    }
}
public class PetrolEngine implements Engine {
   public void start() {...}
}
public class DieselEngine implements Engine {
   public void start() {...}
}
```

- 위 코드가 DIP를 잘 적용한 예이다

## 객체 지향 프로그래밍의 장점

### 소프트웨어의 생산성 향상

- 객체지향 프로그래밍은 다형성, 객체, 캡슐화 등 소프트웨어의 재사용을 지향한다. 이미 만들어진 클래스를 상속받거나 객체를 가져다 재사용하거나, 부분 수정을 통해, 소프트웨어를 작성하는 부담을 대폭 줄일 수 있다.

### 실세계에 대한 쉬운 모델링

- 컴퓨터가 산업 전반에 다양하게 활용되는 요즘 시대에는 응용 소프트웨어를 하나의 절차로 모델링하기 어렵다. 산업 전반에서 요구되는 응용 소프트웨어 특성상, 절차나 과정보다 관련된 많은 객체들의 상호 작용을 묘사하는 것이 더 쉽고 적합하다.

### 보안성 향상

- 객체 지향적 프로그래밍의 캡슐화 특징으로 실제로 구현되는 부분을 외부에 드러나지 않도록 하여 정보를 은닉할 수 있다.
- (캡슐화, 데이터 은니그 다형성으로 인해 필요한 정보를 재정의하거나 getter, setter를 이용하기 때문에 보안성이 높다)

#### 신뢰성 있는 소프트웨어를 손쉽게 작성할 수 있다, 코드를 재사용하기 쉽다, 디버깅이 쉽다 등등

### 객체지향 프로그래밍의 단점

- 느린 실행 속도
  - 객체지향 프로그래밍은 캡슐화와 격리구조 때문에 절차지향 프로그래밍과 비교하면 실행 속도가 느리다. 또한, 객체지향에서는 모든 것을 객체로 생각하기 때문에 추가적인 포인터 크기의 메모리와 연산에 대한 비용이 들어가게 된다.
- 필요한 메모리양의 증가

----

### reference

- https://dokdogalmaegi.tistory.com/48
- https://www.nextree.co.kr/p6960/
- https://chhan.tistory.com/40
- https://www.educative.io/edpresso/what-are-the-solid-principles-in-java
- http://www.incodom.kr/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5
- https://www.jrebel.com/blog/solid-principles-in-java
- https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=swinter8&logNo=130001814757
- https://scienceon.kisti.re.kr/commons/util/originalView.do?cn=JAKO199365349620230&oCn=JAKO199365349620230&dbt=JAKO&journal=NJOU00291002
- https://scienceon.kisti.re.kr/commons/util/originalView.do?cn=JAKO199511919558054&oCn=JAKO199511919558054&dbt=JAKO&journal=NJOU00301561&keyword=%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D

----

